---
title: 单调栈
next:
    text: 下一个更大元素I
    link: /skill/algorithm/monotonic-stack/question496
---

# 单调栈

单调栈是一种常用的数据结构，它通常用于解决区间最值的问题。单调栈是一个栈，它的元素具有单调性，即栈中的元素满足单调递增或单调递减的性质。单调栈常用于解决以下两类问题：

1. 下一个更大元素：给定一个数组，求出每个元素的下一个更大元素。例如，对于数组 `[2, 1, 2, 4, 3]`，它的每个元素的下一个更大元素分别为 `[4, 2, 4, -1, -1]`。
2. 区间最值：给定一个数组和一个滑动窗口的大小，求出每个滑动窗口的最大值或最小值。例如，对于数组 `[1, 3, -1, -3, 5, 3, 6, 7]` 和滑动窗口大小为 3，它的每个滑动窗口的最大值分别为 `[3, 3, 5, 5, 5, 6, 7]`。

单调栈的基本思想是维护一个单调递增或单调递减的栈，当遍历到一个新元素时，将栈中比它小的元素弹出，直到栈顶元素大于等于它。这样，栈中的元素就具有单调性，可以方便地求出每个元素的下一个更大元素或每个滑动窗口的最大值或最小值。

单调栈的时间复杂度通常是 O(N)，其中 N 表示数组的长度或滑动窗口的大小，因此在处理大规模数据时效率较高。单调栈的实现难度较低，因此在面试和竞赛等场合也经常被使用。

举个🌰：

```js
// 计算数组中每个元素后面最近的一个更大元素，如果没有则是-1。
const nums = [2, 1, 5, 6, 2, 3];

/**
常规解题思路：针对于每个元素所在的位置向后遍历，找到比自己大的元素然后放入目标数组
首先创建一个数组用于储存结果，每位都先填充 -1
原数组：[2, 1, 5, 6, 2, 3]，结果数组：[-1, -1, -1, -1, -1, -1]
找寻过程如下：

第一层遍历：
	当前元素：2，下标：0
		第二层遍历，只遍历当前元素后的元素：
			第二层遍历当前元素：1，小于当前元素2，不符条件继续向后遍历
			第二层遍历当前元素：5，大于当前元素2，放入结果数组，跳出当前层循环，目标数组：[5, -1, -1, -1, -1, -1]
	
	当前元素：1，下标：1
		第二层遍历，只遍历当前元素后的元素：
			第二层遍历当前元素：5，大于当前元素1，放入结果数组，跳出当前层循环，目标数组：[5, 5, -1, -1, -1, -1]
	
	当前元素：5，下标：2
		第二层遍历，只遍历当前元素后的元素：
			第二层遍历当前元素：6，大于当前元素5，放入结果数组，跳出当前层循环，目标数组：[5, 5, 6, -1, -1, -1]
	
	当前元素：6，下标：3
		第二层遍历，只遍历当前元素后的元素：
			第二层遍历当前元素：2，小于当前元素6，不符条件继续向后遍历
			第二层遍历当前元素：3，小于当前元素6，已经是最后一个元素，跳出当前层循环

	当前元素：2，下标：4
		第二层遍历，只遍历当前元素后的元素：
			第二层遍历当前元素：3，大于当前元素2，放入结果数组，跳出当前层循环，目标数组：[5, 5, 6, -1, 3, -1]

	当前元素：3，下标：5
		第二层遍历，只遍历当前元素后的元素：
			已经是最后一个元素，直接跳出当前层循环

最终结果：[5, 5, 6, -1, 3, -1]
*/
let result = new Array(nums.length).fill(-1);

for (let i = 0; i < nums.length; i++) {
	for (let j = i + 1; j < nums.length; j++) {
		if (nums[j] > nums[i]) {
			result[i] = nums[j];
			break;
		} 
	}
}

console.log(result) // [5, 5, 6, -1, 3, -1]

/**
单调栈解题思路：创建一个栈，将数组中每一个元素的下标依次入栈，在入栈前先弹出栈中小于当前元素的元素，当前元素就是被弹出的元素对应的后面最近一个更大元素
首先创建一个数组用于储存结果，每位都先填充 -1
原数组：[2, 1, 5, 6, 2, 3]，结果数组：[-1, -1, -1, -1, -1, -1]
再创建一个数组作为栈：[]
找寻过程如下：

遍历原数组：
	当前元素：2，下标：0
		栈中无元素，无需弹出元素
		下标0入栈，结果数组：[-1, -1, -1, -1, -1, -1]，栈：[0]

	当前元素：1，下标：1
		栈中最后一位对应数组中的元素为：2（nums[0]），大于当前元素，无需弹出
		下标1入栈，结果数组：[-1, -1, -1, -1, -1, -1]，栈：[0, 1]

	当前元素：5，下标：2
		栈中最后一位对应数组中的元素为：1（nums[1]），小于当前元素，弹出栈最后一位，并将当前元素设置为其对应结果，结果数组：[-1, 5, -1, -1, -1, -1]，栈：[0]
		弹出之后，栈中最后一位对应数组中的元素为：2（nums[0]），依旧小于当前元素，继续弹出，并将当前元素设置为其对应结果，结果数组：[5, 5, -1, -1, -1, -1]，栈：[]
		栈中无元素，无需再弹出
		下标2入栈，结果数组：[5, 5, -1, -1, -1, -1]，栈：[2]

	当前元素：6，下标：3
		栈中最后一位对应数组中的元素为：5（nums[2]），小于当前元素，弹出栈最后一位，并将当前元素设置为其对应结果，结果数组：[5, 5, 6, -1, -1, -1]，栈：[]
		栈中无元素，无需再弹出
		下标3入栈，结果数组：[5, 5, 6, -1, -1, -1]，栈：[3]

	当前元素：2，下标：4
		栈中最后一位对应数组中的元素为：6（nums[3]），大于当前元素，无需弹出
		下标4入栈，结果数组：[5, 5, 6, -1, -1, -1]，栈：[3, 4]

	当前元素：3，下标：5
		栈中最后一位对应数组中的元素为：2（nums[4]），小于当前元素，弹出最后一位，并将当前元素设置为其对应结果，结果数组：[5, 5, 6, -1, 3, -1]，栈：[3]
		栈中最后一位对应数组中的元素为：6（nums[3]），大于当前元素，无需弹出
		下标5入栈，结果数组：[5, 5, 6, -1, 3, -1]，栈：[3, 5]

遍历结束，最终结果为：[5, 5, 6, -1, 3, -1]
*/
let res = new Array(nums.length).fill(-1);
let stack = [];

for (let i = 0; i < nums.length; i++) {
	while (stack.length > 0 && nums[stack[stack.length - 1]] < nums[i]) {
		res[stack.pop()] = nums[i];
	}
	stack.push(i);
}

console.log(res) // [5, 5, 6, -1, 3, -1]
```

由于上面这个例子比较简单，所以我们可能无法很明确的感知到单调栈的强大，不过在解决一些复杂一点的算法题的时候我们就能够感受到它的那种化腐朽为神奇的能力，后面是一些力扣上可以运用单调栈去解决的一些问题。
