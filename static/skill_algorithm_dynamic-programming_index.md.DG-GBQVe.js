import{_ as a,c as l,o as e,ag as t}from"./chunks/framework.BpgFjFSJ.js";const c=JSON.parse('{"title":"动态规划","description":"","frontmatter":{"title":"动态规划"},"headers":[],"relativePath":"skill/algorithm/dynamic-programming/index.md","filePath":"skill/algorithm/dynamic-programming/index.md"}'),r={name:"skill/algorithm/dynamic-programming/index.md"};function n(o,i,m,p,s,d){return e(),l("div",null,i[0]||(i[0]=[t('<h1 id="动态规划" tabindex="-1">动态规划 <a class="header-anchor" href="#动态规划" aria-label="Permalink to &quot;动态规划&quot;">​</a></h1><p>动态规划（Dynamic Programming）是一种常用的算法设计技术，用于解决具有重叠子问题性质的问题。它通过将问题分解为更小的子问题，并存储子问题的解，以避免重复计算，从而提高算法的效率。</p><p>动态规划通常用于求解最优化问题，其中我们需要找到使某个目标函数最大或最小的值。它的核心思想是将原问题划分为若干子问题，并通过求解子问题的最优解来推导出原问题的最优解。</p><p>动态规划的基本步骤通常如下：</p><ol><li>定义状态：确定问题的状态，将问题表示成状态的集合。状态是原问题中需要保存的关键信息。</li><li>定义状态转移方程：确定状态之间的转移关系，建立状态转移方程。通过定义状态转移方程，可以将原问题的解与子问题的解联系起来。</li><li>初始化：设置初始状态的值，通常是边界情况下的值。</li><li>递推计算：按照状态转移方程，从初始状态开始递推计算所有状态的值，直到得到最终的目标状态的值。</li><li>求解目标：根据最终的状态值，得到原问题的解。</li></ol><p>动态规划算法通常具有以下特点：</p><ul><li>最优子结构：问题的最优解包含了其子问题的最优解。</li><li>重叠子问题：问题可以被分解为若干个子问题，且这些子问题之间存在重叠，即多次计算相同的子问题。</li><li>子问题独立：每个子问题的解只依赖于该子问题的相关状态，而不受其他子问题的影响。</li></ul>',7)]))}const g=a(r,[["render",n]]);export{c as __pageData,g as default};
