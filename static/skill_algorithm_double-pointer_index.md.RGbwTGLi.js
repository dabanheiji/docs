import{_ as i,c as a,o as n,ag as l}from"./chunks/framework.BpgFjFSJ.js";const g=JSON.parse('{"title":"双指针","description":"","frontmatter":{"title":"双指针","next":{"text":"两数之和","link":"/skill/algorithm/double-pointer/question1"}},"headers":[],"relativePath":"skill/algorithm/double-pointer/index.md","filePath":"skill/algorithm/double-pointer/index.md"}'),t={name:"skill/algorithm/double-pointer/index.md"};function h(p,s,k,e,E,r){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="双指针" tabindex="-1">双指针 <a class="header-anchor" href="#双指针" aria-label="Permalink to &quot;双指针&quot;">​</a></h1><p>双指针是一种常用的算法思想，它通常用于解决数组和链表相关的问题。双指针算法的基本思路是使用两个指针指向数组或链表的不同位置，然后根据情况移动指针，以达到解决问题的目的。双指针算法通常可以将时间复杂度降到 O(N) 或 O(NlogN) 等较低的级别。</p><p>双指针算法包括以下几种常见的类型：</p><ol><li>快慢指针：使用两个指针，一个快指针和一个慢指针，通常用于解决链表中的问题，如判断链表是否有环、寻找链表的中间节点等。</li><li>左右指针：使用两个指针，一个左指针和一个右指针，通常用于解决数组或字符串中的问题，如在有序数组中寻找两个数的和、寻找最长回文子串等。</li><li>滑动窗口：使用两个指针，一个指向窗口的左边界，一个指向窗口的右边界，通过移动指针来调整窗口的大小，通常用于解决字符串或数组中的子串或子序列问题，如在字符串中寻找最小覆盖子串、在数组中寻找子数组的最大和等。</li></ol><p>双指针算法的时间复杂度通常是线性的，因此在处理大规模数据时效率较高。由于双指针算法的思路比较简洁，因此在面试和竞赛等场合也经常被使用。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 快慢双指针</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假设head是一个链表的首位</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> show </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast.next) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	show </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> show.next; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 慢指针一次走一步</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast.next.next; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 快指针一次走两步</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 前后双指针</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假设arr是一个数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 分别从前后开始遍历数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (xxx) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		left</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		right</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,6)]))}const y=i(t,[["render",h]]);export{g as __pageData,y as default};
